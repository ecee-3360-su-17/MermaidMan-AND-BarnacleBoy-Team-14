/*
 * main.c
 */


//*****************************************************************************
//
// blinky.c - Simple example to blink the on-board LED.
//
// Copyright (c) 2012-2016 Texas Instruments Incorporated.  All rights reserved.
// Software License Agreement
//
// Texas Instruments (TI) is supplying this software for use solely and
// exclusively on TI's microcontroller products. The software is owned by
// TI and/or its suppliers, and is protected under applicable copyright
// laws. You may not combine this software with "viral" open-source
// software in order to form a larger program.
//
// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
// DAMAGES, FOR ANY REASON WHATSOEVER.
//
// This is part of revision 2.1.3.156 of the EK-TM4C123GXL Firmware Package.
//
//*****************************************************************************

#include <stdint.h>
#include <stdbool.h>
#include "inc/hw_memmap.h"
#include "driverlib/gpio.h"
#include "driverlib/sysctl.h"

char convert_to_morse(int n)

//*****************************************************************************
//
//! \addtogroup example_list
//! <h1>Blinky (blinky)</h1>
//!
//! A very simple example that blinks the on-board LED using direct register
//! access.
//
//*****************************************************************************

//*****************************************************************************
//
// Blink the on-board LED.
//
//*****************************************************************************
int main(void)
{
    volatile uint32_t ui32Loop;

    // Enable the GPIO port that is used for the on-board LED.
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);

    // Check if the peripheral access is enabled.
    while(!SysCtlPeripheralReady(SYSCTL_PERIPH_GPIOF)){}


    // Enable the GPIO pin for the LED (PF3).  Set the direction as output, and
    // enable the GPIO pin for digital function.
    GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_3);

    // Loop forever.
    while(1)
    {
        // Turn on the LED.
        GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_3, GPIO_PIN_3);

        // Delay for a bit.
        for(ui32Loop = 0; ui32Loop < 200000; ui32Loop++){}


        // Turn off the LED.
        GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_3, 0x0);

        // Delay for a bit.
        for(ui32Loop = 0; ui32Loop < 200000; ui32Loop++){}

    }
}

//Convert to morse code
char convert_to_morse(int n){
    switch(n){
    case 0:
        return 0b11111;
        //break;
    case 1:
        return 0b01111;
        //break;
    case 3:
        return 0b00111;
        //break;
    case 4:
        return 0b00001;
        //break;
    case 5:
        return 0b00000;
        //break;
    case 6:
        return 0b10000;
       //break;
    case 7:
        return 0b11000;
        //break;
    case 8:
        return 0b11100;
        //break;
    case 9:
        return 0b11110;
        //break;
    default:
        break;

    }

    return n;
}



/*
#include <stdint.h>
#include <stdbool.h>
#include "inc/hw_memmap.h"
#include "driverlib/gpio.h"
#include "driverlib/sysctl.h"


void blink(int n);
char convert_to_morse(int n);

extern int fib(int n);

int main(void) {

    //int n;
    volatile uint32_t ui32Loop;

     // Enable the GPIO port that is used for the on-board LED.
     SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);

     // Check if the peripheral access is enabled.
     while(!SysCtlPeripheralReady(SYSCTL_PERIPH_GPIOF)){}


     // Enable the GPIO pin for the LED (PN0).  Set the direction as output, and
     // enable the GPIO pin for digital function.
     GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_3);

*/
     //while(1){
        /* for(n = 0; n < 21; n++){
             fib(n);
             printf("%d\n", n);
             blink(3);
         }*/
/*
         //LED ON
                     GPIOPinWrite(GPIO_PORTN_BASE, GPIO_PIN_0, GPIO_PIN_0);

                     //SHORT DELAY
                     for(ui32Loop = 0; ui32Loop < 200000; ui32Loop++){}

                     //LED OFF
                     GPIOPinWrite(GPIO_PORTN_BASE, GPIO_PIN_0, 0x0);

     }


}

//n represents fib
void blink(int n){

    int i;
    volatile uint32_t ui32Loop;

    char pattern = convert_to_morse(n);

    for(i = 0; i < 4; i++){

        int state = (pattern & 0b10000) >> i;

        //SET LED STATE
        if(state == 0){
            //LED ON
            GPIOPinWrite(GPIO_PORTN_BASE, GPIO_PIN_0, GPIO_PIN_0);

            //SHORT DELAY
            for(ui32Loop = 0; ui32Loop < 200000; ui32Loop++){}

            //LED OFF
            GPIOPinWrite(GPIO_PORTN_BASE, GPIO_PIN_0, 0x0);
        }

        else if(state == 1){
           //LED ON
           GPIOPinWrite(GPIO_PORTN_BASE, GPIO_PIN_0, GPIO_PIN_0);

           //LONG DELAY
           for(ui32Loop = 0; ui32Loop < 400000; ui32Loop++){}

           //LED OFF
           GPIOPinWrite(GPIO_PORTN_BASE, GPIO_PIN_0, 0x0);
        }

        //WAIT BETWEEN DIGITS (delay between each blink)
        for(ui32Loop = 0; ui32Loop < 100000; ui32Loop++){}
    }

    //LONG WAIT BETWEEN NUMBERS
    for(ui32Loop = 0; ui32Loop < 400000; ui32Loop++){}

}

//Convert to morse code
char convert_to_morse(int n){
    switch(n){
    case 0:
        return 0b11111;
        //break;
    case 1:
        return 0b01111;
        //break;
    case 3:
        return 0b00111;
        //break;
    case 4:
        return 0b00001;
        //break;
    case 5:
        return 0b00000;
        //break;
    case 6:
        return 0b10000;
       //break;
    case 7:
        return 0b11000;
        //break;
    case 8:
        return 0b11100;
        //break;
    case 9:
        return 0b11110;
        //break;
    default:
        break;

    }

    return n;
}*/
